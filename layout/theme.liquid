<!doctype html>
<html class="no-js" lang="{{ request.locale.iso_code }}">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>{{ page_title }}</title>
    <meta name="google-site-verification" content="4CyyxbiT2JJKwsI1xsr_c7Qf-ihbvBm4WMiPhI0rOeA">
    <meta name="google-site-verification" content="1L3RQDlBxPuNpF21De0Ah8NwPfQRUDie4JA9sbgKwfo">
    <meta name="theme-color" content="">
    {%- if page_description -%}
      <meta name="description" content="{{ page_description | escape }}">
    {% endif %}
    <link rel="preconnect" href="https://cdn.shopify.com" crossorigin="anonymous">
    {%- render 'meta-tags' -%}
    {% render 'web-font' %}
    <link rel="icon" type="image/png" href="{{ settings.favicon | image_url: width: 32, height: 32 }}">
    <script>
      const LCP_SUB_PARTS = [
        'Time to first byte',
        'Resource load delay',
        'Resource load duration',
        'Element render delay',
      ];
      
      new PerformanceObserver((list) => {
        const lcpEntry = list.getEntries().at(-1);
        const navEntry = performance.getEntriesByType('navigation')[0];
        const lcpResEntry = performance
          .getEntriesByType('resource')
          .filter((e) => e.name === lcpEntry.url)[0];
      
        // Ignore LCP entries that aren't images to reduce DevTools noise.
        // Comment this line out if you want to include text entries.
        if (!lcpEntry.url) return;
      
        // Compute the start and end times of each LCP sub-part.
        // WARNING! If your LCP resource is loaded cross-origin, make sure to add
        // the `Timing-Allow-Origin` (TAO) header to get the most accurate results.
        const ttfb = navEntry.responseStart;
        const lcpRequestStart = Math.max(
          ttfb,
          // Prefer `requestStart` (if TOA is set), otherwise use `startTime`.
          lcpResEntry ? lcpResEntry.requestStart || lcpResEntry.startTime : 0
        );
        const lcpResponseEnd = Math.max(
          lcpRequestStart,
          lcpResEntry ? lcpResEntry.responseEnd : 0
        );
        const lcpRenderTime = Math.max(
          lcpResponseEnd,
          // Use LCP startTime (the final LCP time) because there are sometimes
          // slight differences between loadTime/renderTime and startTime
          // due to rounding precision.
          lcpEntry ? lcpEntry.startTime : 0
        );
      
        // Clear previous measures before making new ones.
        // Note: due to a bug, this doesn't work in Chrome DevTools.
        LCP_SUB_PARTS.forEach((part) => performance.clearMeasures(part));
      
        // Create measures for each LCP sub-part for easier
        // visualization in the Chrome DevTools Performance panel.
        const lcpSubPartMeasures = [
          performance.measure(LCP_SUB_PARTS[0], {
            start: 0,
            end: ttfb,
          }),
          performance.measure(LCP_SUB_PARTS[1], {
            start: ttfb,
            end: lcpRequestStart,
          }),
          performance.measure(LCP_SUB_PARTS[2], {
            start: lcpRequestStart,
            end: lcpResponseEnd,
          }),
          performance.measure(LCP_SUB_PARTS[3], {
            start: lcpResponseEnd,
            end: lcpRenderTime,
          }),
        ];
      
        // Log helpful debug information to the console.
        console.log('LCP value: ', lcpRenderTime);
        console.log('LCP element: ', lcpEntry.element, lcpEntry.url);
        console.table(
          lcpSubPartMeasures.map((measure) => ({
            'LCP sub-part': measure.name,
            'Time (ms)': measure.duration,
            '% of LCP': `${
              Math.round((1000 * measure.duration) / lcpRenderTime) / 10
            }%`,
          }))
        );
      }).observe({type: 'largest-contentful-paint', buffered: true});
    </script>
    <script>
      (async function () {
                    async function measureRTTAndDownlink(url) {
                        const startTime = performance.now();
                        let rtt = null, downlink = null;

                        try {
                          // 单次网络请求用于测量 RTT 和下载速度
                          const response = await fetch(url, { method: "GET", cache: "no-cache" });
                          const endTime = performance.now();
                          rtt = Math.round(endTime - startTime);

                          const blob = await response.blob();
                          const fileSizeBytes = blob.size; // 文件大小（字节）
                          const durationSeconds = (endTime - startTime) / 1000; // 持续时间（秒）

                          downlink = Math.round((fileSizeBytes * 8) / (durationSeconds * 1024 * 1024)); // Mbps
                        } catch (error) {
                          console.warn("测量 RTT 和下载速度失败:", error);
                        }

                        return { rtt, downlink };
                      }

                      function estimateEffectiveType(downlink, rtt) {
                        if (downlink < 0.5 || rtt > 300) return "2g";
                        if (downlink < 1.5 || rtt > 150) return "3g";
                        if (downlink < 20 || rtt > 50) return "4g";
                        return "5g";
                      }

                      async function testNetwork() {
                        const url = "https://cdn.shopify.com"; // 替换为可靠的小文件 URL
                        const { rtt, downlink } = await measureRTTAndDownlink(url);

                        const effectiveType = estimateEffectiveType(downlink, rtt);
                        return { downlink, rtt, effectiveType };
                      }

                      async function getNetworkInfo() {
                        const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
                        let networkInfo = {
                          type: "unknown",
                          effectiveType: "unknown",
                          downlink: "unknown",
                          rtt: "unknown",
                          saveData: false,
                        };

                        if (connection) {
                          // 使用 Network Information API
                          networkInfo.type = connection.type || "unknown";
                          networkInfo.effectiveType = connection.effectiveType || "unknown";
                          networkInfo.downlink = connection.downlink || "unknown";
                          networkInfo.rtt = connection.rtt || "unknown";
                          networkInfo.saveData = connection.saveData || false;
                        }

                        // 测速补充数据
                        const testResult = await testNetwork();
                        networkInfo.downlink = testResult.downlink || networkInfo.downlink;
                        networkInfo.rtt = testResult.rtt || networkInfo.rtt;
                        networkInfo.effectiveType = testResult.effectiveType || networkInfo.effectiveType;

                        return networkInfo;
          }

        function evaluateNetworkQuality(networkInfo) {
            let totalWeight = 0;
            let weightedScore = 0;

            // Type 权重
            const typeWeights = {
              wifi: { baseScore: 1, weight: 2 },
              cellular: { baseScore: 2, weight: 3 },
              none: { baseScore: 5, weight: 5 },
              unknown: { baseScore: 1.5, weight: 2 },
            };

            const typeData = typeWeights[networkInfo.type] || { baseScore: 3, weight: 2 };
            weightedScore += typeData.baseScore * typeData.weight;
            totalWeight += typeData.weight;

            // EffectiveType 权重
            const effectiveTypeWeights = {
              "5g": { baseScore: 1, weight: 3 },
              "4g": { baseScore: 1.5, weight: 2 },
              "3g": { baseScore: 2.5, weight: 2 },
              "2g": { baseScore: 4, weight: 3 },
              "unknown": { baseScore: 2, weight: 2 },
            };

            const effectiveTypeData = effectiveTypeWeights[networkInfo.effectiveType] || { baseScore: 2, weight: 2 };
            weightedScore += effectiveTypeData.baseScore * effectiveTypeData.weight;
            totalWeight += effectiveTypeData.weight;

            // Downlink 权重（线性映射）
            if (networkInfo.downlink !== "unknown") {
              let downlinkScore = 5; // 默认最低分
              if (networkInfo.downlink >= 20) downlinkScore = 1; // 卓越
              else if (networkInfo.downlink >= 10) downlinkScore = 1.5;
              else if (networkInfo.downlink >= 5) downlinkScore = 2.5;
              else if (networkInfo.downlink >= 1) downlinkScore = 3.5;
              else if (networkInfo.downlink >= 0.5) downlinkScore = 4.5;

              weightedScore += downlinkScore * 4;
              totalWeight += 4;
            } else {
              weightedScore += 3 * 2; // 默认值
              totalWeight += 2;
            }

            // RTT 权重（线性映射）
            if (networkInfo.rtt !== "unknown") {
              let rttScore = 5; // 默认最低分
              if (networkInfo.rtt <= 50) rttScore = 1; // 卓越
              else if (networkInfo.rtt <= 200) rttScore = 2;
              else if (networkInfo.rtt <= 500) rttScore = 3;
              else if (networkInfo.rtt <= 1000) rttScore = 4;
              else rttScore = 5; // 极差

              weightedScore += rttScore * 3;
              totalWeight += 3;
            } else {
              weightedScore += 3 * 1;
              totalWeight += 1;
            }

            // SaveData 权重
            if (networkInfo.saveData) {
              weightedScore += 5 * 1; // 流量保护启用，网络质量较差
              totalWeight += 1;
            } else {
              weightedScore += 1 * 1; // 未启用流量保护
              totalWeight += 1;
            }

            // 综合得分（返回小数，精确到两位）
            const averageScore = (weightedScore / totalWeight).toFixed(2);

            return parseFloat(averageScore);
          }




          const pattern = [
            ['src', 'shopify-perf-kit', 300],
            ['src', 'https://www.google-analytics.com/analytics.js', 300],
            ['id', 'web-pixels-manager-setup', 1000],
            ['className', 'analytics', 300]
          ]
          // 存储 head 中的 script 标签信息
          const scriptQueue = [];
          // 监听 DOM 的添加
          const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
              mutation.addedNodes.forEach((node) => {
                if (node.tagName === 'SCRIPT' && node.parentElement.tagName === 'HEAD') {
                for (const [attr, value, delay] of pattern) {
                  if (node[attr] && node[attr].includes(value)) {
                    scriptQueue.push({
                      src: node.src,
                      content: node.src ? null : node.innerText,
                      type: node.type || 'text/javascript',
                      isInline: !!!node.src,
                      delay,
                      attrs: Array.from(node.attributes).map(attr => [attr.name, attr.value])
                    });

                    node.remove();
                    break;
                  }
                }
                }
              });
            });
          });

          // 开始观察 head 的变动
          observer.observe(document.head, { childList: true });
          let networkInfo = getNetworkInfo();
          // 等待页面加载完成后执行收集的 script
          window.addEventListener('load', async () => {
              networkInfo = await networkInfo;
              const networkQuality = evaluateNetworkQuality(networkInfo);
              console.log("networkInfo", JSON.stringify(networkInfo), networkQuality);

            document.querySelectorAll('script[type="text/lazyload"]').forEach(elem => {
              const delay = elem.getAttribute('data-delay')

              if (!Number.isNaN(delay)) {
                setTimeout(() => {
                  elem.type = "text/javascript";
                  elem.src = elem.src;
                  elem.async = false;
                }, parseInt(Number(delay) * networkQuality))
              }
            })

            scriptQueue.forEach((script) => {
              const newScript = document.createElement('script');

              if (script.isInline) {
                newScript.textContent = script.content;
              } else {
                newScript.src = script.src;
              }

              newScript.type = script.type;

              for (const [attr, value] of script.attrs) {
                newScript.setAttribute(attr, value)
              }

              setTimeout(() => {
                document.head.appendChild(newScript); // 执行脚本
              }, parseInt(script.delay * networkQuality))
            });

            // 停止观察
            observer.disconnect();
          });
        })();
    </script>
    <script src="{{ 'libs.min.js' | asset_url }}" fetchpriority="high" type="module"></script>
    <script src="{{ 'global.js' | asset_url }}" fetchpriority="low" defer></script>
    {% comment %} {{ content_for_header }} {% endcomment %}
    {{
      content_for_header
      | replace: 'preloads.js?locale=en-US"', 'preloads.js?locale=en-US" type="text/lazyload" data-delay="2000"'
      | replace: "'load', asyncLoad, false);", "'load', () => setTimeout(asyncLoad, 1000), false);"
      | replace: 'data-source-attribution="shopify.loadfeatures" defer="defer"',
        'data-source-attribution="shopify.loadfeatures" data-delay="300" type="text/lazyload"'
    }}
    {% render 'global-config' %}
    {% render 'pagefly-app-header' %}
  </head>
  <body class="gradient">
    {{ 'base.css' | asset_url | stylesheet_tag: preload: true }}
    {{ 'tailwind.min.css' | asset_url | stylesheet_tag: preload: true }}
    {% section 'announcement-bar' %}
    {% section 'header' %}
    <main id="MainContent" class="content-for-layout focus-none" role="main" tabindex="-1">
      {{ content_for_layout }}
    </main>
    {% section 'care' %}
    {% section 'footer' %}
    {%- render 'cart-drawer' -%}
    <script
      type="module"
    >
      window.shopUrl = '{{ request.origin }}';
      window.routes = {
        cart_add_url: '{{ routes.cart_add_url }}',
        cart_change_url: '{{ routes.cart_change_url }}',
        cart_update_url: '{{ routes.cart_update_url }}',
        cart_url: '{{ routes.cart_url }}',
        predictive_search_url: '{{ routes.predictive_search_url }}',
      };

      window.cartStrings = {
        error: `{{ 'sections.cart.cart_error' | t }}`,
        quantityError: `{{ 'sections.cart.cart_quantity_error_html' | t: quantity: '[quantity]' }}`,
      };

      window.variantStrings = {
        addToCart: `{{ 'products.product.add_to_cart' | t }}`,
        soldOut: `{{ 'products.product.sold_out' | t }}`,
        unavailable: `{{ 'products.product.unavailable' | t }}`,
      };

      window.accessibilityStrings = {
        imageAvailable: `{{ 'products.product.media.image_available' | t: index: '[index]' }}`,
        shareSuccess: `{{ 'general.share.success_message' | t }}`,
        pauseSlideshow: `{{ 'sections.slideshow.pause_slideshow' | t }}`,
        playSlideshow: `{{ 'sections.slideshow.play_slideshow' | t }}`,
      };
    </script>
  </body>
  {% render 'lozad' %}
  {% render 'dataLayer-allPages' %}
  {% render 'dialog' %}
  {% if product or request.path == '/pages/test-ride' or request.path == '/pages/urtopia-e-bike-review' %}
    {% render 'judgeme_core' %}
  {% endif %}
</html>
